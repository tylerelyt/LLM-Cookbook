# Lesson 2: 工具遮蔽策略与动态行为控制

本课程基于Manus的"Mask, Don't Remove"原则，学习如何通过工具遮蔽而非移除来优化Agent行为，避免缓存失效的同时提升决策质量。

## 🎯 学习目标

- **工具遮蔽原理**: 理解为什么遮蔽优于移除工具
- **状态机设计**: 构建上下文感知的工具可用性管理
- **Logits操控**: 通过Token约束实现精确的行为控制  
- **MCP集成**: 处理大规模工具集合的挑战

## 🔧 核心挑战

### 工具爆炸问题
随着Agent能力扩展，工具数量急剧增长：
- **用户配置**: 用户可能插入数百个神秘工具
- **决策混乱**: 过多选择导致Agent选择错误或低效路径
- **性能下降**: "武装到牙齿"的Agent反而变得更笨

### 传统解决方案的问题
动态添加/移除工具看似合理，但存在致命缺陷：
1. **缓存失效**: 工具定义变化导致KV-Cache失效
2. **上下文错乱**: 历史行为引用已删除的工具定义

## 💡 Manus的解决方案

### 状态机 + 遮蔽策略
- **保持工具定义**: 所有工具始终在上下文中定义
- **Logits遮蔽**: 通过Token约束控制实际可用性
- **前缀设计**: 工具命名采用一致前缀便于批量控制

### 三种函数调用模式
基于Hermes格式的响应预填充：

1. **Auto模式**: `<|im_start|>assistant`
   - Agent可选择是否调用函数

2. **Required模式**: `<|im_start|>assistant<tool_call>`
   - 必须调用函数，但选择不受限

3. **Specified模式**: `<|im_start|>assistant<tool_call>{"name": "browser_`
   - 必须从特定子集中选择函数

## 🛠️ 实践练习

### 练习1: 智能工具管理器
构建一个能够根据上下文动态遮蔽工具的管理系统。

### 练习2: 状态机驱动Agent
实现基于状态机的Agent行为控制框架。

### 练习3: MCP工具集成
处理大规模MCP工具集合的遮蔽策略。

## 📁 文件说明

- `tool_masker.py`: 核心工具遮蔽实现
- `state_machine.py`: 上下文感知状态机
- `logits_processor.py`: Token级别的约束处理
- `mcp_manager.py`: MCP工具集成管理

## 🚀 开始实践

```bash
# 安装依赖
pip install -r requirements.txt

# 运行工具遮蔽示例
python tool_masker.py

# 测试状态机控制
python state_machine.py --demo

# MCP集成演示
python mcp_manager.py --tools 100
```

## 💡 设计原则

> "不要移除工具，而是遮蔽它们。这样既保持了缓存效率，又避免了上下文混乱。"
> — Manus AI Team

### 关键实现细节
- **前缀命名**: `browser_*`, `shell_*` 等一致前缀
- **无状态处理器**: 避免使用有状态的logits处理器
- **确定性遮蔽**: 保证相同上下文产生相同遮蔽结果

## 🔍 高级话题

- **动态前缀匹配**: 实现灵活的工具分组
- **条件遮蔽**: 基于复杂条件的工具可用性
- **性能优化**: 大规模工具集的高效遮蔽
- **调试技巧**: 工具遮蔽状态的可视化 